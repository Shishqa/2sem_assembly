     1                                  ;;=========================================================================
     2                                  ;; itoa.asm                                             Shishqa, MIPT 2020
     3                                  ;;=========================================================================
     4                                  
     5                                              default rel
     6                                  
     7                                              section .text
     8                                  
     9                                              global  _itoa
    10                                  
    11                                  ;;=========================================================================
    12                                  ;; Convert unsigned int number to string in base representation
    13                                  ;;
    14                                  ;; Danger! Writes from end to begin of the number
    15                                  ;; So, RDI should point to the place where the number
    16                                  ;; should end.
    17                                  ;;
    18                                  ;;                  v-RDI_entry
    19                                  ;; buffer: _1_2_3_4_5_
    20                                  ;;          ^-RDI_exit
    21                                  ;;
    22                                  ;; ENTRY: ESI <- unsigned int number
    23                                  ;;        RDI <- addr of string buffer end
    24                                  ;;         DH <- binary degree of base if binary, 0 if not
    25                                  ;;         DL <- base (<= 16)
    26                                  ;; Exit:  RDI -> addr of the last written digit
    27                                  ;; Destr: RAX RBX RDX RSI ; DF
    28                                  ;;=========================================================================
    29                                  
    30                                  _itoa:
    31 00000000 488D1D(05000000)                    lea     rbx, [DIGITS]               ; RBX points to DIGITS arr
    32 00000007 FD                                  std                                 ; set dest. flag (R to L)
    33                                  
    34 00000008 8815(01000000)                      mov     byte [BASE], dl             ; BASE = DL
    35 0000000E 80FE00                              cmp     dh, 0                       ; !binary => ordinary_division
    36 00000011 742D                                je      .ordinary_division          ; binary  => shift_division
    37                                  
    38 00000013 FF0D(01000000)                      dec     dword [BASE]                ; BASE = 11..11 (mask)
    39 00000019 8835(00000000)                      mov     byte [SHIFT], dh            ; SHIFT = DH
    40                                  
    41                                  .binary_division:
    42                                  
    43 0000001F 4831C0                              xor     rax, rax                    ; RAX = 0
    44 00000022 89F0                                mov     eax, esi
    45 00000024 2305(01000000)                      and     eax, dword [BASE]           ; AL = ESI % BASE
    46                                  
    47 0000002A D7                                  xlatb                               ; AL = [DIGITS + AL]
    48 0000002B AA                                  stosb                               ; [RDI++] = AL
    49                                  
    50 0000002C 8A05(00000000)                      mov     al, byte [SHIFT]            ; AL = SHIFT
    51                                  .shr_loop:                                      ; loop: ESI <<= AL
    52 00000032 D1EE                                shr     esi, 1
    53 00000034 48FFC8                              dec     rax
    54 00000037 75F9                                jnz     .shr_loop                   ; while (SHIFT--) EDI >> 1;
    55                                  
    56 00000039 83FE00                              cmp     esi, 0
    57 0000003C 75E1                                jne     .binary_division            ; if done, exit
    58 0000003E EB17                                jmp     .exit
    59                                  
    60                                  .ordinary_division:
    61                                  
    62 00000040 31D2                                xor     edx, edx                    ; 0:ESI / BASE = EAX * BASE + EDX
    63 00000042 89F0                                mov     eax, esi
    64 00000044 F735(01000000)                      div     dword [BASE]
    65                                  
    66 0000004A 89C6                                mov     esi, eax                    ; ESI <- QUOTIENT
    67 0000004C 88D0                                mov     al, dl                      ; AL <- REMAINDER
    68                                  
    69 0000004E D7                                  xlatb                               ; AL = [DIGITS + AL]
    70 0000004F AA                                  stosb                               ; [RDI++] = AL
    71                                  
    72 00000050 83FE00                              cmp     esi, 0
    73 00000053 75EB                                jne     .ordinary_division          ; if done, exit
    74 00000055 EB00                                jmp     .exit
    75                                  
    76                                  .exit:
    77 00000057 48FFC7                              inc     rdi                         ; [RDI] == first digit
    78                                  
    79 0000005A C3                                  ret
    80                                  
    81                                  ;;-------------------------------------------------------------------------
    82                                  
    83                                              section .data
    84 00000000 00                      SHIFT:      db 0
    85 00000001 00000000                BASE:       dd 0
    86 00000005 303132333435363738-     DIGITS:     db "0123456789ABCDEF"
    86 0000000E 39414243444546     
    87                                  
    88                                  ;;=========================================================================
